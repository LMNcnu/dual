#include <moveit/move_group_interface/move_group.h>
#include <math.h>
#include  <std_msgs/Float32MultiArray.h>//define joints
#include <iostream>

int main(int argc, char **argv)
{
  ros::init(argc, argv, "three_state_circulation_moveJ");
  ros::NodeHandle node_handle;  
  ros::AsyncSpinner spinner(1);
  spinner.start();
  
  //sleep(20.0);//等rviz起来，如果没在一个lanuch中，可以省去这个

  moveit::planning_interface::MoveGroup group("joint_group");

  // Getting Basic Information
  ROS_INFO("Reference frame: %s", group.getPlanningFrame().c_str());//打印坐标系
  ROS_INFO("Reference frame: %s", group.getEndEffectorLink().c_str());//打印末端链节

/*定义关节组位置数组，并得到当前位置，修改某些关节值，然后规划显示*/
  std::vector<double> group_variable_values;
  std::vector<double> home_values;
  group.getCurrentState()->copyJointGroupPositions(group.getCurrentState()->getRobotModel()->getJointModelGroup(group.getName()), home_values);
  moveit::planning_interface::MoveGroup::Plan my_plan1;
  moveit::planning_interface::MoveGroup::Plan my_plan2;
  moveit::planning_interface::MoveGroup::Plan my_plan3;

  group.getCurrentState()->copyJointGroupPositions(group.getCurrentState()->getRobotModel()->getJointModelGroup(group.getName()), group_variable_values);
  group_variable_values[1] = -1.5;
  group_variable_values[2] = -1.0;
  group_variable_values[3] = -1.0;
  group_variable_values[4] = -1.0;
  group_variable_values[5] =  1.5;
  //group_variable_values[6] =  1.5;
  group.setJointValueTarget(group_variable_values);
  group.allowLooking(false);  
  group.plan(my_plan1);
  group.execute(my_plan1);

  home_values[0] = 0;
  home_values[1] = 0;
  home_values[2] = 0;
  home_values[3] = 0;
  home_values[4] = 0;
  home_values[5] = 0;
 // home_values[6] = 0;
  group.setJointValueTarget(home_values);
  group.plan(my_plan2);
  group.execute(my_plan2);

  group_variable_values[1] = 1.5;
  group_variable_values[2] = 1.0;
  group_variable_values[3] = 1.0;
  group_variable_values[4] = 1.0;
  group_variable_values[5] = -1.5;
  //group_variable_values[6] = -1.5;
  group.setJointValueTarget(group_variable_values);
  group.allowLooking(false);  
  group.plan(my_plan3);
  group.execute(my_plan3);

  /*publish the point's position*/
  std_msgs::Float32MultiArray joints;
  joints.data.resize(6);

  ros::NodeHandle nh;
  ros::Publisher command_pub = nh.advertise<std_msgs::Float32MultiArray> ("moveJ", 1000);
  ros::Rate loop_rate(20);//Hz
  int j =0;
  while(ros::ok())
  {
	  group.execute(my_plan2);
	  for(j=0; j<my_plan1.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan1.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(2);
	  group.execute(my_plan1);
	  for(j=0; j<my_plan2.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan2.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(2);
	  group.execute(my_plan2);
	  for(j=0; j<my_plan1.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan1.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(2);
	  group.execute(my_plan3);
	  for(j=0; j<my_plan2.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan3.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(2);
  }



  sleep(5.0); //Sleep to give Rviz time to visualize the plan.  

  ros::shutdown();  
  return 0;

}

