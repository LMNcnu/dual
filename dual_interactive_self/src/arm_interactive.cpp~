#include <moveit/move_group_interface/move_group.h>
#include <math.h>
#include  <std_msgs/Float32MultiArray.h>//define joints
#include <iostream>

//#include <moveit/move_group_interface/move_group.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>

#include <moveit_msgs/DisplayRobotState.h>
#include <moveit_msgs/DisplayTrajectory.h>

#include <moveit_msgs/AttachedCollisionObject.h>
#include <moveit_msgs/CollisionObject.h>

#include <moveit_msgs/PlanningScene.h>

int main(int argc, char **argv)
{
  ros::init(argc, argv, "arm_interactive");
  ros::NodeHandle node_handle;  
  ros::AsyncSpinner spinner(1);
  spinner.start();
  
  //sleep(20.0);//等rviz起来，如果没在一个lanuch中，可以省去这个

  moveit::planning_interface::MoveGroup group("arm_group");

  // Getting Basic Information
  ROS_INFO("Reference frame: %s", group.getPlanningFrame().c_str());//打印坐标系
  ROS_INFO("Reference frame: %s", group.getEndEffectorLink().c_str());//打印末端链节
sleep(10);
//添加物体
  moveit::planning_interface::PlanningSceneInterface planning_scene_interface;

    // Adding/Removing Objects and Attaching/Detaching Objects
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // First, we will define the collision object message.
    moveit_msgs::CollisionObject collision_object;

    collision_object.header.frame_id =group.getPlanningFrame();

    /* The id of the object is used to identify it. */
    collision_object.id = "box1";

    /* Define a box to add to the world. */
    shape_msgs::SolidPrimitive primitive;
    primitive.type = primitive.BOX;
    primitive.dimensions.resize(3);
    primitive.dimensions[0] = 0.4;
    primitive.dimensions[1] = 0.1;
    primitive.dimensions[2] = 0.4;

    /* A pose for the box (specified relative to frame_id) */
    geometry_msgs::Pose box_pose;
    box_pose.orientation.w = 1.0;
    box_pose.position.x =  1;
    box_pose.position.y =1;
    box_pose.position.z =  1;

    collision_object.primitives.push_back(primitive);
    collision_object.primitive_poses.push_back(box_pose);
    collision_object.operation = collision_object.ADD;

    std::vector<moveit_msgs::CollisionObject> collision_objects;
    collision_objects.push_back(collision_object);

    // Now, let's add the collision object into the world
    ROS_INFO("Add an object into the world");
    planning_scene_interface.addCollisionObjects(collision_objects);

    /* Sleep so we have time to see the object in RViz */
    sleep(10.0);

// Advertise the required topic
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Note that this topic may need to be remapped in the launch file
    ros::Publisher planning_scene_diff_publisher = node_handle.advertise<moveit_msgs::PlanningScene>("planning_scene", 1);
    while(planning_scene_diff_publisher.getNumSubscribers() < 1)
    {
      ros::WallDuration sleep_t(0.5);
      sleep_t.sleep();
    }

  // Define the attached object message
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // We will use this message to add or
  // subtract the object from the world
  // and to attach the object to the robot
    moveit_msgs::AttachedCollisionObject attached_object;
    attached_object.link_name = "link8";
    /* The header must contain a valid TF frame*/
    attached_object.object.header.frame_id = group.getPlanningFrame();

    /* The id of the object */
    attached_object.object.id = "box2";

    /* A default pose */
    geometry_msgs::Pose pose;
    pose.orientation.w = 1.0;
    pose.position.x=0.4;
    pose.position.y=0.4;
    pose.position.z=0.4;

    /* Define a box to be attached */
    shape_msgs::SolidPrimitive primitive2;
    primitive2.type = primitive2.BOX;
    primitive2.dimensions.resize(3);
    primitive2.dimensions[0] = 0.4;
    primitive2.dimensions[1] = 0.4;
    primitive2.dimensions[2] = 0.4;

    attached_object.object.primitives.push_back(primitive2);
    attached_object.object.primitive_poses.push_back(pose);

  // Note that attaching an object to the robot requires
  // the corresponding operation to be specified as an ADD operation
    attached_object.object.operation = attached_object.object.ADD;


  // Add an object into the environment
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Add the object into the environment by adding it to
  // the set of collision objects in the "world" part of the
  // planning scene. Note that we are using only the "object"
  // field of the attached_object message here.
    ROS_INFO("Adding the object into the world at the location of the right wrist.");
    moveit_msgs::PlanningScene planning_scene;
    planning_scene.world.collision_objects.push_back(attached_object.object);
    planning_scene.is_diff = true;
    planning_scene_diff_publisher.publish(planning_scene);
    sleep(2);






/*定义关节组位置数组，并得到当前位置，修改某些关节值，然后规划显示*/
  std::vector<double> group_variable_values;
  std::vector<double> home_values;
  group.getCurrentState()->copyJointGroupPositions(group.getCurrentState()->getRobotModel()->getJointModelGroup(group.getName()), home_values);
  moveit::planning_interface::MoveGroup::Plan my_plan1;
  moveit::planning_interface::MoveGroup::Plan my_plan2;
  moveit::planning_interface::MoveGroup::Plan my_plan3;

  group.getCurrentState()->copyJointGroupPositions(group.getCurrentState()->getRobotModel()->getJointModelGroup(group.getName()), group_variable_values);
  group_variable_values[1] = -1.5;
  group_variable_values[2] = -1.0;
  group_variable_values[3] = -1.0;
  group_variable_values[4] = -1.0;
  group_variable_values[5] =  1.5;
  group_variable_values[6] =  1.5;
  group.setJointValueTarget(group_variable_values);
  group.allowLooking(false);  
  group.plan(my_plan1);
  group.execute(my_plan1);















  home_values[0] = 0;
  home_values[1] = 0;
  home_values[2] = 0;
  home_values[3] = 0;
  home_values[4] = 0;
  home_values[5] = 0;
  home_values[6] = 0;
  group.setJointValueTarget(home_values);
  group.plan(my_plan2);
  group.execute(my_plan2);

  group_variable_values[1] = 1.5;
  group_variable_values[2] = 1.0;
  group_variable_values[3] = 1.0;
  group_variable_values[4] = 1.0;
  group_variable_values[5] = -1.5;
  group_variable_values[6] = -1.5;
  group.setJointValueTarget(group_variable_values);
  group.allowLooking(false);  
  group.plan(my_plan3);
  group.execute(my_plan3);

  /*publish the point's position*/
  std_msgs::Float32MultiArray joints;
  joints.data.resize(6);

  ros::NodeHandle nh;
  ros::Publisher command_pub = nh.advertise<std_msgs::Float32MultiArray> ("moveJ", 1000);
  ros::Rate loop_rate(20);//Hz
  int j =0;
  while(ros::ok())
  {
	  group.execute(my_plan2);
	  for(j=0; j<my_plan1.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan1.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(4);
	  group.execute(my_plan1);
	  for(j=0; j<my_plan2.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan2.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(4);
	  group.execute(my_plan2);
	  for(j=0; j<my_plan1.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan1.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(4);
	  group.execute(my_plan3);
	  for(j=0; j<my_plan2.trajectory_.joint_trajectory.points.size(); j++)
	  {
	      for(int i=0; i<6; i++)
	     {
		  joints.data[i]=my_plan3.trajectory_.joint_trajectory.points[j].positions[i];
		  ROS_INFO("send ponits[%d]positions[%d] %f",j,i,joints.data[i]);
	     }
	      command_pub.publish(joints);
	      loop_rate.sleep();
	  }
sleep(4);
  }



  sleep(5.0); //Sleep to give Rviz time to visualize the plan.  

  ros::shutdown();  
  return 0;

}

